[
    {
        "id": 0,
        "verdict": "Plagiarism",
        "label": 1,
        "student_code": "def check_if_same(text):\n    new_string = [letter.lower() for letter in text if letter.isalnum()]\n    index_start = 0\n    index_end = len(new_string) - 1\n\n    while index_start < index_end:\n        if new_string[index_start] != new_string[index_end]:\n            return False\n        index_start += 1\n        index_end -= 1\n    return True",
        "original_code": "def isPalindrome(self, s: str) -> bool:\n        filtered_chars = [char.lower() for char in s if char.isalnum()]\n        return filtered_chars == filtered_chars[::-1]",
        "type": "POSITIVE (PLAGIARISM)"
    },
    {
        "id": 1,
        "verdict": "Original",
        "label": 0,
        "student_code": "def threeSum_alternative(nums):\n    n = len(nums)\n    result = []\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if nums[i] + nums[j] + nums[k] == 0:\n                    triplet = sorted([nums[i], nums[j], nums[k]])\n                    if triplet not in result:\n                        result.append(triplet)\n\n    return result",
        "original_code": "def threeSum(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        nums.sort()\n        length = len(nums)\n        for i in range(length - 2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i + 1, length - 1\n            while l < r:\n                total = nums[i] + nums[l] + nums[r]\n                if total < 0:\n                    l += 1\n                elif total > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l+1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r-1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n        return res",
        "type": "NEGATIVE (ORIGINAL)"
    },
    {
        "id": 2,
        "verdict": "Plagiarism",
        "label": 1,
        "student_code": "def find_max_subarray(self, numbers: list[int]) -> int:\n    # Placeholder for Divide and Conquer strategy\n    return self.maxSubArray(numbers)",
        "original_code": "def maxSubArrayDnC(self, nums: List[int]) -> int:\n        # Placeholder for Divide and Conquer approach\n        return self.maxSubArray(nums)",
        "type": "POSITIVE (PLAGIARISM)"
    },
    {
        "id": 3,
        "verdict": "Original",
        "label": 0,
        "student_code": "def minDepth(root: TreeNode) -> int:\n    if not root:\n        return 0\n    \n    if not root.left and not root.right:\n        return 1\n    \n    if not root.left:\n        return 1 + minDepth(root.right)\n    \n    if not root.right:\n        return 1 + minDepth(root.left)\n\n    return 1 + min(minDepth(root.left), minDepth(root.right))",
        "original_code": "def maxDepth(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))",
        "type": "NEGATIVE (ORIGINAL)"
    },
    {
        "id": 4,
        "verdict": "Plagiarism",
        "label": 1,
        "student_code": "def near_dupes(arr, limit):\n    if len(arr) <= limit + 1: return len(arr) != len(set(arr))\n    if limit == 0: return False\n    seen = set(arr[:limit])\n    i = limit\n    while i < len(arr):\n        if arr[i] in seen: return True\n        else:\n            seen.remove(arr[i - limit])\n            seen.add(arr[i])\n        i += 1\n    return False",
        "original_code": "def containsNearbyDuplicate(self, nums, k):\n    if len(nums) <= k + 1: return len(nums) != len(set(nums))\n    if k == 0: return False\n    s = set(nums[:k])\n    for i in range(k, len(nums)):\n        if nums[i] in s: return True\n        else:\n            s.remove(nums[i - k])\n            s.add(nums[i])\n    return False",
        "type": "POSITIVE (PLAGIARISM)"
    },
    {
        "id": 5,
        "verdict": "Original",
        "label": 0,
        "student_code": "def isValid(s: str) -> bool:\n    n = len(s)\n    if n % 2 != 0:\n        return False\n    \n    open_brackets = '([{'\n    close_brackets = ')]}'\n    \n    while '()' in s or '[]' in s or '{}' in s:\n        s = s.replace('()', '').replace('[]', '').replace('{}', '')\n        \n    return len(s) == 0",
        "original_code": "def isValid(self, s: str) -> bool:\n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n                if mapping[char] != top_element:\n                    return False\n            else:\n                stack.append(char)\n        return not stack",
        "type": "NEGATIVE (ORIGINAL)"
    },
    {
        "id": 6,
        "verdict": "Plagiarism",
        "label": 1,
        "student_code": "def find_penultimate(self, start_node):\n    store = set()\n\n    def traverse(node):\n        if node:\n            store.add(node.val)\n            traverse(node.left)\n            traverse(node.right)\n\n    traverse(start_node)\n    unique_vals = sorted(list(store))\n    if len(unique_vals) > 1:\n        return unique_vals[1]\n    else:\n        return -1",
        "original_code": "def findSecondMinimumValue(self, root: TreeNode) -> int:\n        result = []\n        self.preorder(root, result)\n        return sorted(result)[1] if len(result) > 1 else -1",
        "type": "POSITIVE (PLAGIARISM)"
    },
    {
        "id": 7,
        "verdict": "Original",
        "label": 0,
        "student_code": "def is_alphanumeric(char):\n    alphabets = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    numbers = \"0123456789\"\n    combined = alphabets + numbers\n    return char in combined",
        "original_code": "def alphaNum(self, c):\n        return (ord('A') <= ord(c) <= ord('Z') or \n                ord('a') <= ord(c) <= ord('z') or \n                ord('0') <= ord(c) <= ord('9'))",
        "type": "NEGATIVE (ORIGINAL)"
    },
    {
        "id": 8,
        "verdict": "Plagiarism",
        "label": 1,
        "student_code": "def traverse(matrix, row, col):\n    if row < 0 or col < 0 or row >= len(matrix) or col >= len(matrix[0]) or matrix[row][col] != '1':\n        return\n    matrix[row][col] = '#'\n    traverse(matrix, row+1, col)\n    traverse(matrix, row-1, col)\n    traverse(matrix, row, col+1)\n    traverse(matrix, row, col-1)",
        "original_code": "def dfs(self, grid, i, j):\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] != '1':\n            return\n        grid[i][j] = '#'\n        self.dfs(grid, i+1, j)\n        self.dfs(grid, i-1, j)\n        self.dfs(grid, i, j+1)\n        self.dfs(grid, i, j-1)",
        "type": "POSITIVE (PLAGIARISM)"
    },
    {
        "id": 9,
        "verdict": "Original",
        "label": 0,
        "student_code": "def are_identical_trees(root1, root2):\n    if root1 is None and root2 is None:\n        return True\n    if root1 is None or root2 is None:\n        return False\n    if root1.val != root2.val:\n        return False\n    return are_identical_trees(root1.left, root2.left) and are_identical_trees(root1.right, root2.right)",
        "original_code": "def isSymmetric(self, root: TreeNode) -> bool:\n        return self.isMirror(root, root)",
        "type": "NEGATIVE (ORIGINAL)"
    },
    {
        "id": 10,
        "verdict": "Plagiarism",
        "label": 1,
        "student_code": "class TreeNode:\n    def __init__(self, worth=0, towardLeft=None, towardRight=None):\n        self.worth = worth\n        self.towardLeft = towardLeft\n        self.towardRight = towardRight",
        "original_code": "def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
        "type": "POSITIVE (PLAGIARISM)"
    },
    {
        "id": 11,
        "verdict": "Original",
        "label": 0,
        "student_code": "def reverseListRecursive(head: ListNode) -> ListNode:\n    if not head or not head.next:\n        return head\n    \n    new_head = reverseListRecursive(head.next)\n    head.next.next = head\n    head.next = None\n    \n    return new_head",
        "original_code": "def reverseList(self, head: ListNode) -> ListNode:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev",
        "type": "NEGATIVE (ORIGINAL)"
    },
    {
        "id": 12,
        "verdict": "Plagiarism",
        "label": 1,
        "student_code": "def array_constructor(n: int, k: int) -> list[int]:\n    outcome = []\n    seen = set()\n    multiplier = k + 1\n    i = 1\n    while i <= n:\n        if i not in seen:\n            outcome.append(i)\n            seen.add(i)\n        if multiplier not in seen:\n            outcome.append(multiplier)\n            seen.add(multiplier)\n        multiplier -= 1\n        i += 1\n    return outcome",
        "original_code": "def constructArray(self, n: int, k: int) -> List[int]:\n        array = []\n        visited = set()\n        k += 1\n        for i in range(n):\n            i += 1\n            if i not in visited:\n                array.append(i)\n                visited.add(i)\n            if k not in visited:\n                array.append(k)\n                visited.add(k)\n                k -= 1\n        return array",
        "type": "POSITIVE (PLAGIARISM)"
    },
    {
        "id": 13,
        "verdict": "Original",
        "label": 0,
        "student_code": "def invertTreeRecursive(root: TreeNode) -> TreeNode:\n    if not root:\n        return None\n    \n    # Recursively invert the left and right subtrees\n    root.left = invertTreeRecursive(root.left)\n    root.right = invertTreeRecursive(root.right)\n    \n    # Swap the left and right children\n    root.left, root.right = root.right, root.left\n    \n    return root",
        "original_code": "def invertTreeIterative(self, root: TreeNode) -> TreeNode:\n        if not root: return None\n        queue = [root]\n        while queue:\n            current = queue.pop(0)\n            current.left, current.right = current.right, current.left\n            if current.left: queue.append(current.left)\n            if current.right: queue.append(current.right)\n        return root",
        "type": "NEGATIVE (ORIGINAL)"
    },
    {
        "id": 14,
        "verdict": "Plagiarism",
        "label": 1,
        "student_code": "def recursive_cached(input_value):\n    cache_storage = {}\n    def _recursive_cached(input_val):\n        if input_val in cache_storage: return cache_storage[input_val]\n        if input_val <= 2: return input_val\n        cache_storage[input_val] = _recursive_cached(input_val-1) + _recursive_cached(input_val-2)\n        return cache_storage[input_val]\n    return _recursive_cached(input_value)",
        "original_code": "def helper(x):\n            if x in memo: return memo[x]\n            if x <= 2: return x\n            memo[x] = helper(x-1) + helper(x-2)\n            return memo[x]",
        "type": "POSITIVE (PLAGIARISM)"
    },
    {
        "id": 15,
        "verdict": "Original",
        "label": 0,
        "student_code": "def search(self, nums: List[int], target: int) -> int:\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n    return -1",
        "original_code": "def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] < target:\n                l = mid + 1\n            elif nums[mid] > target:\n                r = mid - 1\n            else:\n                return mid\n        return -1",
        "type": "NEGATIVE (ORIGINAL)"
    },
    {
        "id": 16,
        "verdict": "Plagiarism",
        "label": 1,
        "student_code": "def combine_ranges(time_slots): # Renamed function and variable\n    time_slots.sort(key=lambda x: x[0]) # Kept sort logic the same\n    combined_slots = [] # Renamed variable\n    i = 0\n    while i < len(time_slots):\n        current_slot = time_slots[i] # Renamed variable\n        if not combined_slots or combined_slots[-1][1] < current_slot[0]:\n            combined_slots.append(current_slot)\n        else:\n            combined_slots[-1][1] = max(combined_slots[-1][1], current_slot[1])\n        i += 1\n    return combined_slots",
        "original_code": "def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort(key=lambda x: x[0])\n        merged = []\n        for interval in intervals:\n            if not merged or merged[-1][1] < interval[0]:\n                merged.append(interval)\n            else:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n        return merged",
        "type": "POSITIVE (PLAGIARISM)"
    },
    {
        "id": 17,
        "verdict": "Original",
        "label": 0,
        "student_code": "def diagonalValueShuffle(self, mat: List[List[int]], row: int, col: int) -> None:\n    diagonal_values = []\n    r, c = row, col\n    # gather values\n    while r < self.rows and c < self.cols:\n        diagonal_values.append(mat[r][c])\n        r += 1\n        c += 1\n    \n    import random\n    random.shuffle(diagonal_values)\n\n    r, c = row, col\n    i = 0\n    # replace current values with shuffled\n    while r < self.rows and c < self.cols:\n        mat[r][c] = diagonal_values[i]\n        i += 1\n        r += 1\n        c += 1",
        "original_code": "def diagonalValueSort(self, mat: List[List[int]], row: int, col: int) -> None:\n        diagonal_values = []\n        # gather values\n        while row < self.rows and col < self.cols:\n            diagonal_values.append(mat[row][col])\n            row += 1\n            col += 1\n        # sort values\n        diagonal_values.sort()\n        # replace current values with sorted\n        while row > 0 and col > 0:\n            row -= 1\n            col -= 1\n            mat[row][col] = diagonal_values.pop()",
        "type": "NEGATIVE (ORIGINAL)"
    },
    {
        "id": 18,
        "verdict": "Plagiarism",
        "label": 1,
        "student_code": "def __init__(self, value=0, l_node=None, r_node=None):\n        self.data = value\n        self.prev = l_node\n        self.next = r_node",
        "original_code": "def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
        "type": "POSITIVE (PLAGIARISM)"
    },
    {
        "id": 19,
        "verdict": "Original",
        "label": 0,
        "student_code": "def reverseListRecursive(head: ListNode) -> ListNode:\n    if not head or not head.next:\n        return head\n    \n    new_head = reverseListRecursive(head.next)\n    head.next.next = head\n    head.next = None\n    \n    return new_head",
        "original_code": "def reverseList(self, head: ListNode) -> ListNode:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev",
        "type": "NEGATIVE (ORIGINAL)"
    },
    {
        "id": 20,
        "verdict": "Plagiarism",
        "label": 1,
        "student_code": "def sum_thrice_target(numbers, objective):\n    tally = 0\n    frequency = Counter(numbers)\n    distinct_numbers = list(frequency.keys())\n    size = len(distinct_numbers)\n    modulus = 1000000007\n\n    for x in range(size):\n        y = x\n        while y < size:\n            if objective - distinct_numbers[x] - distinct_numbers[y] in frequency:\n                if distinct_numbers[x] == distinct_numbers[y] == objective-distinct_numbers[x]-distinct_numbers[y]:\n                    tally += frequency[distinct_numbers[x]] * (frequency[distinct_numbers[x]]-1) * (frequency[distinct_numbers[x]]-2) // 6\n                elif distinct_numbers[x] == distinct_numbers[y]:\n                    tally += frequency[objective-distinct_numbers[x]-distinct_numbers[y]] * (frequency[distinct_numbers[x]]) * (frequency[distinct_numbers[x]]-1) // 2\n                elif distinct_numbers[x] < objective-distinct_numbers[x]-distinct_numbers[y] and distinct_numbers[y] < objective-distinct_numbers[x]-distinct_numbers[y]:\n                    tally += frequency[distinct_numbers[x]] * frequency[distinct_numbers[y]] * frequency[objective-distinct_numbers[x]-distinct_numbers[y]]\n            y += 1\n\n    return tally % modulus",
        "original_code": "def threeSumMulti(self, arr: List[int], target: int) -> int:\n        count = 0\n        counter = Counter(arr)\n        arr = list(counter.keys())\n        length = len(arr)\n        modulo = 1000000007\n\n        for i in range(length):\n            for j in range(i, length):\n                if target - arr[i] - arr[j] in counter:\n                    if arr[i] == arr[j] == target-arr[i]-arr[j]:\n                        count += counter[arr[i]] * (counter[arr[i]]-1) * (counter[arr[i]]-2) // 6\n                    elif arr[i] == arr[j]:\n                        count += counter[target-arr[i]-arr[j]] * (counter[arr[i]]) * (counter[arr[i]]-1) // 2\n                    elif arr[i] < target-arr[i]-arr[j] and arr[j] < target-arr[i]-arr[j]:\n                        count += counter[arr[i]] * counter[arr[j]] * counter[target-arr[i]-arr[j]]\n\n        return count % modulo",
        "type": "POSITIVE (PLAGIARISM)"
    },
    {
        "id": 21,
        "verdict": "Original",
        "label": 0,
        "student_code": "def iterative_inorder(root):\n    if not root:\n        return []\n\n    result = []\n    stack = []\n    curr = root\n\n    while curr or stack:\n        while curr:\n            stack.append(curr)\n            curr = curr.left\n\n        curr = stack.pop()\n        result.append(curr.val)\n        curr = curr.right\n\n    return result",
        "original_code": "def traverse(self, root, postorder):\n        if not root:\n            return 0\n        self.traverse(root.left, postorder)\n        self.traverse(root.right, postorder)\n        postorder.append(root.val)",
        "type": "NEGATIVE (ORIGINAL)"
    },
    {
        "id": 22,
        "verdict": "Plagiarism",
        "label": 1,
        "student_code": "def find_it(numbers, aim):\n    left, right = 0, len(numbers) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if numbers[middle] < aim:\n            left = middle + 1\n        elif numbers[middle] > aim:\n            right = middle - 1\n        else:\n            return middle\n    return -1",
        "original_code": "def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] < target:\n                l = mid + 1\n            elif nums[mid] > target:\n                r = mid - 1\n            else:\n                return mid\n        return -1",
        "type": "POSITIVE (PLAGIARISM)"
    },
    {
        "id": 23,
        "verdict": "Original",
        "label": 0,
        "student_code": "class Node:\n    def __init__(self, val=0):\n        self.value = val\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)",
        "original_code": "def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next",
        "type": "NEGATIVE (ORIGINAL)"
    },
    {
        "id": 24,
        "verdict": "Plagiarism",
        "label": 1,
        "student_code": "class Node:\n    def __init__(self, data = 0, prev = None, next_node = None):\n        self.data_value = data\n        self.prev_node = prev\n        self.next_node = next_node",
        "original_code": "def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
        "type": "POSITIVE (PLAGIARISM)"
    },
    {
        "id": 25,
        "verdict": "Original",
        "label": 0,
        "student_code": "def deleteNode_iterative(root, key):\n    if not root:\n        return None\n\n    parent = None\n    curr = root\n    while curr:\n        if key < curr.val:\n            parent = curr\n            curr = curr.left\n        elif key > curr.val:\n            parent = curr\n            curr = curr.right\n        else:\n            # Node found, perform deletion\n            if not curr.left and not curr.right: # No children\n                if not parent: # Deleting root\n                    return None\n                elif parent.left == curr:\n                    parent.left = None\n                else:\n                    parent.right = None\n                return root\n            elif not curr.left: # Only right child\n                if not parent: # Deleting root\n                    return curr.right\n                elif parent.left == curr:\n                    parent.left = curr.right\n                else:\n                    parent.right = curr.right\n                return root\n            elif not curr.right: # Only left child\n                if not parent: # Deleting root\n                    return curr.left\n                elif parent.left == curr:\n                    parent.left = curr.left\n                else:\n                    parent.right = curr.left\n                return root\n            else: # Two children\n                # Find inorder predecessor (max value in left subtree)\n                pred_parent = curr\n                predecessor = curr.left\n                while predecessor.right:\n                    pred_parent = predecessor\n                    predecessor = predecessor.right\n\n                # Copy the inorder predecessor's data to the current node\n                curr.val = predecessor.val\n\n                # Delete the inorder predecessor\n                if pred_parent.left == predecessor:\n                    pred_parent.left = predecessor.left\n                else:\n                    pred_parent.right = predecessor.left\n                return root\n    return root\n",
        "original_code": "def deleteNode(self, root, key):\n    if not root: return None\n    if key < root.val: \n        root.left = self.deleteNode(root.left, key)\n    elif key > root.val:\n        root.right = self.deleteNode(root.right, key)\n    else:\n        # if this node has only one child or no child:\n        if not root.left:\n            temp = root.right\n            root = None\n            return temp\n        elif not root.right:\n            temp = root.left\n            root = None\n            return temp\n        \n        # otherwise, find the inorder successor:\n        curr = root.right\n        while curr.left:\n            curr = curr.left\n        \n        root.val = curr.val\n        root.right = self.deleteNode(root.right, curr.val)\n    return root",
        "type": "NEGATIVE (ORIGINAL)"
    },
    {
        "id": 26,
        "verdict": "Plagiarism",
        "label": 1,
        "student_code": "def are_symmetric(node1, node2):\n    if not node1 and not node2:\n        return True\n    if not node1 or not node2:\n        return False\n\n    return (node1.val == node2.val) and \\\n           are_symmetric(node1.right, node2.left) and \\\n           are_symmetric(node1.left, node2.right)",
        "original_code": "def isMirror(self, t1, t2):\n        if not t1 and not t2: return True\n        if not t1 or not t2: return False\n        return (t1.val == t2.val) and                self.isMirror(t1.right, t2.left) and                self.isMirror(t1.left, t2.right)",
        "type": "POSITIVE (PLAGIARISM)"
    },
    {
        "id": 27,
        "verdict": "Original",
        "label": 0,
        "student_code": "def is_alphanumeric(char):\n    \"\"\"Checks if a character is alphanumeric using string membership.\n\n    This function checks if a given character is alphanumeric by verifying if it's present in\n    a predefined string containing all alphanumeric characters.\n    \"\"\"\n    alphanumeric_chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n    return char in alphanumeric_chars",
        "original_code": "def alphaNum(self, c):\n        return (ord('A') <= ord(c) <= ord('Z') or \n                ord('a') <= ord(c) <= ord('z') or \n                ord('0') <= ord(c) <= ord('9'))",
        "type": "NEGATIVE (ORIGINAL)"
    },
    {
        "id": 28,
        "verdict": "Plagiarism",
        "label": 1,
        "student_code": "class TreeNode:\n    def __init__(self, value=0, left_child=None, right_child=None):\n        self.value = value\n        self.left_child = left_child\n        self.right_child = right_child",
        "original_code": "def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
        "type": "POSITIVE (PLAGIARISM)"
    },
    {
        "id": 29,
        "verdict": "Original",
        "label": 0,
        "student_code": "def find_target(nums, target):\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n    return -1",
        "original_code": "def helper(l, r):\n            if l > r: return -1\n            mid = (l + r) // 2\n            if nums[mid] == target: return mid\n            if nums[mid] < target: return helper(mid + 1, r)\n            return helper(l, mid - 1)",
        "type": "NEGATIVE (ORIGINAL)"
    }
]