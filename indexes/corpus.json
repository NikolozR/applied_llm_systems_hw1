[
    {
        "doc_id": 0,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "658.FindKClosestElements.py",
        "text": "def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:\n        length = len(arr)\n        l = 0\n        r = length - 1\n        while l + 1 < r:\n            m = (l + r) // 2\n            if arr[m-1] <= x <= arr[m]:\n                l, r = self.pickNumber(arr, m, k, x, length)\n                return arr[l: r+1]\n            if x < arr[m]:\n                r = m\n            else:\n                l = m\n        if l == 0:\n            return arr[:min(k, length)]\n        if r == length - 1:\n            return arr[-k:]"
    },
    {
        "doc_id": 0,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "658.FindKClosestElements.py",
        "text": "def pickNumber(self, arr, m, k, x, length):\n        result = []\n        i = 1\n        j = 0\n        while k > 0:\n            if m + j > length - 1:\n                result.sort()\n                return result[0] - k, result[-1]\n            if m-i >= 0 and x - arr[m-i] <= arr[m + j] - x:\n                result.append(m-i)\n                i += 1\n            else:\n                result.append(m + j)\n                j += 1\n            k -= 1\n        result.sort()\n        return result[0], result[-1]"
    },
    {
        "doc_id": 1,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "104.MaximumDepthofBinaryTree.py",
        "text": "def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right"
    },
    {
        "doc_id": 1,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "104.MaximumDepthofBinaryTree.py",
        "text": "def maxDepth(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"
    },
    {
        "doc_id": 1,
        "chunk_id": 2,
        "chunk_type": "function",
        "file_name": "104.MaximumDepthofBinaryTree.py",
        "text": "def maxDepthBFS(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        level = 0\n        q = [root]\n        while q:\n            for i in range(len(q)):\n                node = q.pop(0)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            level += 1\n        return level"
    },
    {
        "doc_id": 2,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "200.NumberOfIslands.py",
        "text": "def numIslands(self, grid: List[List[str]]) -> int:\n        if not grid:\n            return 0\n        count = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1':\n                    self.dfs(grid, i, j)\n                    count += 1\n        return count"
    },
    {
        "doc_id": 2,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "200.NumberOfIslands.py",
        "text": "def dfs(self, grid, i, j):\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] != '1':\n            return\n        grid[i][j] = '#'\n        self.dfs(grid, i+1, j)\n        self.dfs(grid, i-1, j)\n        self.dfs(grid, i, j+1)\n        self.dfs(grid, i, j-1)"
    },
    {
        "doc_id": 3,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "2.AddTwoNumbers.py",
        "text": "def add2Numbers(x, k):\n    t = x + k\n    return x + k"
    },
    {
        "doc_id": 4,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "238.ProductofArrayExceptSelf.py",
        "text": "def productExceptSelf(self, nums: List[int]) -> List[int]:\n        length = len(nums)\n        answer = [0] * length\n        answer[0] = 1\n        for i in range(1, length):\n            answer[i] = nums[i - 1] * answer[i - 1]\n        R = 1\n        for i in reversed(range(length)):\n            answer[i] = answer[i] * R\n            R *= nums[i]\n        return answer"
    },
    {
        "doc_id": 4,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "238.ProductofArrayExceptSelf.py",
        "text": "def calculatePrefixProducts(self, nums: List[int]) -> List[int]:\n        prefix = [1] * len(nums)\n        for i in range(1, len(nums)):\n            prefix[i] = prefix[i-1] * nums[i-1]\n        return prefix"
    },
    {
        "doc_id": 5,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "671.SecondMinimumNodeInaBinaryTree.py",
        "text": "def findSecondMinimumValue(self, root: TreeNode) -> int:\n        result = []\n        self.preorder(root, result)\n        return sorted(result)[1] if len(result) > 1 else -1"
    },
    {
        "doc_id": 5,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "671.SecondMinimumNodeInaBinaryTree.py",
        "text": "def preorder(self, root, result):\n        if not root:\n            return 0\n        if root.val not in result:\n            result.append(root.val)\n        if root.left:\n            self.preorder(root.left, result)\n        if root.right:\n            self.preorder(root.right, result)"
    },
    {
        "doc_id": 6,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "BinaryTreeMaximumPathSum.py",
        "text": "def maxPathSum(self, root: TreeNode) -> int:\n        self.sum = -9999999999 #float('-inf')\n        self.getSum(root)\n        return self.sum"
    },
    {
        "doc_id": 6,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "BinaryTreeMaximumPathSum.py",
        "text": "def getSum(self, root):\n        if root is None: return 0\n        left = self.getSum(root.left)\n        right = self.getSum(root.right)\n        max_in_node = max(max(left, right) + root.val, root.val)\n        max_sum = max(max_in_node, left + right + root.val)\n        self.sum = max(self.sum, max_sum)\n        return max_in_node"
    },
    {
        "doc_id": 7,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "1.TwoSum.py",
        "text": "def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hashmap = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in hashmap:\n                return [hashmap[complement], i]\n            hashmap[num] = i\n        return []"
    },
    {
        "doc_id": 7,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "1.TwoSum.py",
        "text": "def twoSumBruteForce(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]\n        return []"
    },
    {
        "doc_id": 8,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "19.RemoveNthNodeFromEndofList.py",
        "text": "def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next"
    },
    {
        "doc_id": 8,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "19.RemoveNthNodeFromEndofList.py",
        "text": "def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        dummy = ListNode(0, head)\n        left = dummy\n        right = head\n        while n > 0 and right:\n            right = right.next\n            n -= 1\n        while right:\n            left = left.next\n            right = right.next\n        left.next = left.next.next\n        return dummy.next"
    },
    {
        "doc_id": 9,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "121.BestTimetoBuyandSellStock.py",
        "text": "def maxProfit(self, prices: List[int]) -> int:\n        min_price = float('inf')\n        max_profit = 0\n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        return max_profit"
    },
    {
        "doc_id": 9,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "121.BestTimetoBuyandSellStock.py",
        "text": "def maxProfitBruteForce(self, prices: List[int]) -> int:\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i + 1, len(prices)):\n                profit = prices[j] - prices[i]\n                if profit > max_profit:\n                    max_profit = profit\n        return max_profit"
    },
    {
        "doc_id": 10,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "771.JewelsandStones.py",
        "text": "def numJewelsInStones(self, J: str, S: str) -> int:\n        i = len(J) - 1\n        count = 0\n        while i >= 0:\n            if J[i] in S:\n                count += S.count(J[i])\n            i -= 1\n        return count"
    },
    {
        "doc_id": 11,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "101.SymmetricTree.py",
        "text": "def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right"
    },
    {
        "doc_id": 11,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "101.SymmetricTree.py",
        "text": "def isSymmetric(self, root: TreeNode) -> bool:\n        return self.isMirror(root, root)"
    },
    {
        "doc_id": 11,
        "chunk_id": 2,
        "chunk_type": "function",
        "file_name": "101.SymmetricTree.py",
        "text": "def isMirror(self, t1, t2):\n        if not t1 and not t2: return True\n        if not t1 or not t2: return False\n        return (t1.val == t2.val) and                self.isMirror(t1.right, t2.left) and                self.isMirror(t1.left, t2.right)"
    },
    {
        "doc_id": 11,
        "chunk_id": 3,
        "chunk_type": "function",
        "file_name": "101.SymmetricTree.py",
        "text": "def isSymmetricIterative(self, root: TreeNode) -> bool:\n        if not root: return True\n        q = [root, root]\n        while q:\n            t1 = q.pop(0)\n            t2 = q.pop(0)\n            if not t1 and not t2: continue\n            if not t1 or not t2: return False\n            if t1.val != t2.val: return False\n            q.append(t1.left)\n            q.append(t2.right)\n            q.append(t1.right)\n            q.append(t2.left)\n        return True"
    },
    {
        "doc_id": 12,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "1345.JumpGameIV.py",
        "text": "def minJumps(self, arr: List[int]) -> int:\n        indices = {}\n        visited = set()\n        queue = [[0, 0]] # index, step\n        length = len(arr)\n        for ind, num in enumerate(arr):\n            if num not in indices:\n                indices[num] = []\n            indices[num].append(ind)\n        while queue:\n            index, steps = queue.pop(0)\n            if index == length - 1:\n                break\n            if indices[arr[index]]:\n                for i in indices[arr[index]]:\n                    if i not in visited:\n                        visited.add(i)\n                        queue.append([i, steps+1])\n                indices[arr[index]] = []\n            if index - 1 > 0 and index - 1 not in visited:\n                visited.add(index-1)\n                queue.append([index-1, steps+1])\n            if index + 1 not in visited:\n                visited.add(index+1)\n                queue.append([index+1, steps+1])\n        return steps"
    },
    {
        "doc_id": 13,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "21.MergeTwoSortedLists.py",
        "text": "def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next"
    },
    {
        "doc_id": 13,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "21.MergeTwoSortedLists.py",
        "text": "def mergeTwoLists(self, list1: ListNode, list2: ListNode) -> ListNode:\n        dummy = ListNode()\n        tail = dummy\n        while list1 and list2:\n            if list1.val < list2.val:\n                tail.next = list1\n                list1 = list1.next\n            else:\n                tail.next = list2\n                list2 = list2.next\n            tail = tail.next\n        if list1:\n            tail.next = list1\n        elif list2:\n            tail.next = list2\n        return dummy.next"
    },
    {
        "doc_id": 13,
        "chunk_id": 2,
        "chunk_type": "function",
        "file_name": "21.MergeTwoSortedLists.py",
        "text": "def mergeTwoListsRecursive(self, l1: ListNode, l2: ListNode) -> ListNode:\n        if not l1: return l2\n        if not l2: return l1\n        if l1.val < l2.val:\n            l1.next = self.mergeTwoListsRecursive(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoListsRecursive(l1, l2.next)\n            return l2"
    },
    {
        "doc_id": 14,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "56.MergeIntervals.py",
        "text": "def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort(key=lambda x: x[0])\n        merged = []\n        for interval in intervals:\n            if not merged or merged[-1][1] < interval[0]:\n                merged.append(interval)\n            else:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n        return merged"
    },
    {
        "doc_id": 14,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "56.MergeIntervals.py",
        "text": "def isOverlapping(self, a: List[int], b: List[int]) -> bool:\n        return max(a[0], b[0]) <= min(a[1], b[1])"
    },
    {
        "doc_id": 15,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "116.PopulatingNextRightPointersinEachNode.py",
        "text": "def connect(self, root: 'Node') -> 'Node':\n        if not root:\n            return root\n        queue = [root]\n        while queue:\n            length = len(queue)\n            level = []\n            while length:\n                node = queue.pop(0)\n                level.append(node)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                length -= 1\n            l = len(level)\n            for i in range(l):\n                if i == l - 1:\n                    level[i].next = None\n                if i + 1 < l:\n                    level[i].next = level[i+1]\n        return root"
    },
    {
        "doc_id": 16,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "923.3SumWithMultiplicity.py",
        "text": "def threeSumMulti(self, arr: List[int], target: int) -> int:\n        count = 0\n        counter = Counter(arr)\n        arr = list(counter.keys())\n        length = len(arr)\n        modulo = 1000000007\n\n        for i in range(length):\n            for j in range(i, length):\n                if target - arr[i] - arr[j] in counter:\n                    if arr[i] == arr[j] == target-arr[i]-arr[j]:\n                        count += counter[arr[i]] * (counter[arr[i]]-1) * (counter[arr[i]]-2) // 6\n                    elif arr[i] == arr[j]:\n                        count += counter[target-arr[i]-arr[j]] * (counter[arr[i]]) * (counter[arr[i]]-1) // 2\n                    elif arr[i] < target-arr[i]-arr[j] and arr[j] < target-arr[i]-arr[j]:\n                        count += counter[arr[i]] * counter[arr[j]] * counter[target-arr[i]-arr[j]]\n\n        return count % modulo"
    },
    {
        "doc_id": 17,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "123.BestTimetoBuyandSellStockIII.py",
        "text": "def maxProfit(self, prices: List[int]) -> int:\n        transaction_one = float(inf)\n        transaction_two = float(inf)\n        current_profit = 0\n        total_profit = 0\n        for price in prices:\n            transaction_one = min(transaction_one, price)\n            current_profit = max(current_profit, price - transaction_one)\n            transaction_two = min(transaction_two, price - current_profit)\n            total_profit = max(total_profit, price - transaction_two)\n        return total_profit"
    },
    {
        "doc_id": 18,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "1338.ReduceArraySizetoTheHalf.py",
        "text": "def minSetSize(self, arr: List[int]) -> int:\n        numbers = {}\n        half = len(arr) // 2\n        for number in arr:\n            if number not in numbers:\n                numbers[number] = 1\n            else:\n                numbers[number] += 1\n        for index, value in enumerate(sorted(list(numbers.values()), reverse=True)):\n            half -= value\n            if half <= 0:\n                return index + 1"
    },
    {
        "doc_id": 19,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "667.BeautifulArrangementII.py",
        "text": "def constructArray(self, n: int, k: int) -> List[int]:\n        array = []\n        visited = set()\n        k += 1\n        for i in range(n):\n            i += 1\n            if i not in visited:\n                array.append(i)\n                visited.add(i)\n            if k not in visited:\n                array.append(k)\n                visited.add(k)\n                k -= 1\n        return array"
    },
    {
        "doc_id": 20,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "15.3Sum.py",
        "text": "def threeSum(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        nums.sort()\n        length = len(nums)\n        for i in range(length - 2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i + 1, length - 1\n            while l < r:\n                total = nums[i] + nums[l] + nums[r]\n                if total < 0:\n                    l += 1\n                elif total > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l+1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r-1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n        return res"
    },
    {
        "doc_id": 21,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "145.BinaryTreePostorderTraversal.py",
        "text": "def postorderTraversal(self, root: TreeNode) -> List[int]:\n        postorder = []\n        self.traverse(root, postorder)\n        return postorder"
    },
    {
        "doc_id": 21,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "145.BinaryTreePostorderTraversal.py",
        "text": "def traverse(self, root, postorder):\n        if not root:\n            return 0\n        self.traverse(root.left, postorder)\n        self.traverse(root.right, postorder)\n        postorder.append(root.val)"
    },
    {
        "doc_id": 22,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "70.ClimbingStairs.py",
        "text": "def climbStairs(self, n: int) -> int:\n        if n == 1:\n            return 1\n        first = 1\n        second = 2\n        for i in range(3, n + 1):\n            third = first + second\n            first = second\n            second = third\n        return second"
    },
    {
        "doc_id": 22,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "70.ClimbingStairs.py",
        "text": "def climbStairsRecursive(self, n: int) -> int:\n        memo = {}\n        def helper(x):\n            if x in memo: return memo[x]\n            if x <= 2: return x\n            memo[x] = helper(x-1) + helper(x-2)\n            return memo[x]\n        return helper(n)"
    },
    {
        "doc_id": 22,
        "chunk_id": 2,
        "chunk_type": "function",
        "file_name": "70.ClimbingStairs.py",
        "text": "def helper(x):\n            if x in memo: return memo[x]\n            if x <= 2: return x\n            memo[x] = helper(x-1) + helper(x-2)\n            return memo[x]"
    },
    {
        "doc_id": 23,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "242.ValidAnagram.py",
        "text": "def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        countS, countT = {}, {}\n        for i in range(len(s)):\n            countS[s[i]] = countS.get(s[i], 0) + 1\n            countT[t[i]] = countT.get(t[i], 0) + 1\n        return countS == countT"
    },
    {
        "doc_id": 23,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "242.ValidAnagram.py",
        "text": "def isAnagramSorting(self, s: str, t: str) -> bool:\n        return sorted(s) == sorted(t)"
    },
    {
        "doc_id": 24,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "236.LowestCommonAncestor.py",
        "text": "def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None"
    },
    {
        "doc_id": 24,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "236.LowestCommonAncestor.py",
        "text": "def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        if not root or root == p or root == q:\n            return root\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        if left and right:\n            return root\n        return left if left else right"
    },
    {
        "doc_id": 24,
        "chunk_id": 2,
        "chunk_type": "function",
        "file_name": "236.LowestCommonAncestor.py",
        "text": "def findPath(self, root, target, path):\n        if not root: return False\n        path.append(root)\n        if root == target: return True\n        if self.findPath(root.left, target, path) or self.findPath(root.right, target, path):\n            return True\n        path.pop()\n        return False"
    },
    {
        "doc_id": 25,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "1325.DeleteLeavesWithaGivenValue.py",
        "text": "def removeLeafNodes(self, root: TreeNode, target: int) -> TreeNode:\n        self.dfs(root, target)\n        if root and root.val == target and not root.left and not root.right:\n            root = None\n        return root"
    },
    {
        "doc_id": 25,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "1325.DeleteLeavesWithaGivenValue.py",
        "text": "def dfs(self, root, target):\n        if not root:\n            return\n        self.dfs(root.left, target)\n        self.dfs(root.right, target)\n        if root.left and root.left.val == target and not root.left.left and not root.left.right:\n            root.left = None\n        if root.right and root.right.val == target and not root.right.left and not root.right.right:\n            root.right = None"
    },
    {
        "doc_id": 26,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "226.InvertBinaryTree.py",
        "text": "def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right"
    },
    {
        "doc_id": 26,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "226.InvertBinaryTree.py",
        "text": "def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        return root"
    },
    {
        "doc_id": 26,
        "chunk_id": 2,
        "chunk_type": "function",
        "file_name": "226.InvertBinaryTree.py",
        "text": "def invertTreeIterative(self, root: TreeNode) -> TreeNode:\n        if not root: return None\n        queue = [root]\n        while queue:\n            current = queue.pop(0)\n            current.left, current.right = current.right, current.left\n            if current.left: queue.append(current.left)\n            if current.right: queue.append(current.right)\n        return root"
    },
    {
        "doc_id": 27,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "141.LinkedListCycle.py",
        "text": "def __init__(self, x):\n        self.val = x\n        self.next = None"
    },
    {
        "doc_id": 27,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "141.LinkedListCycle.py",
        "text": "def hasCycle(self, head: ListNode) -> bool:\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n        return False"
    },
    {
        "doc_id": 27,
        "chunk_id": 2,
        "chunk_type": "function",
        "file_name": "141.LinkedListCycle.py",
        "text": "def hasCycleSet(self, head: ListNode) -> bool:\n        seen = set()\n        curr = head\n        while curr:\n            if curr in seen:\n                return True\n            seen.add(curr)\n            curr = curr.next\n        return False"
    },
    {
        "doc_id": 28,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "deletenode.py",
        "text": "def deleteNode(self, root, key):\n    if not root: return None\n    if key < root.val: \n        root.left = self.deleteNode(root.left, key)\n    elif key > root.val:\n        root.right = self.deleteNode(root.right, key)\n    else:\n        # if this node has only one child or no child:\n        if not root.left:\n            temp = root.right\n            root = None\n            return temp\n        elif not root.right:\n            temp = root.left\n            root = None\n            return temp\n        \n        # otherwise, find the inorder successor:\n        curr = root.right\n        while curr.left:\n            curr = curr.left\n        \n        root.val = curr.val\n        root.right = self.deleteNode(root.right, curr.val)\n    return root"
    },
    {
        "doc_id": 29,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "206.ReverseLinkedList.py",
        "text": "def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next"
    },
    {
        "doc_id": 29,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "206.ReverseLinkedList.py",
        "text": "def reverseList(self, head: ListNode) -> ListNode:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
    },
    {
        "doc_id": 29,
        "chunk_id": 2,
        "chunk_type": "function",
        "file_name": "206.ReverseLinkedList.py",
        "text": "def reverseListRecursive(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        p = self.reverseListRecursive(head.next)\n        head.next.next = head\n        head.next = None\n        return p"
    },
    {
        "doc_id": 30,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "704.BinarySearch.py",
        "text": "def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] < target:\n                l = mid + 1\n            elif nums[mid] > target:\n                r = mid - 1\n            else:\n                return mid\n        return -1"
    },
    {
        "doc_id": 30,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "704.BinarySearch.py",
        "text": "def searchRecursive(self, nums: List[int], target: int) -> int:\n        def helper(l, r):\n            if l > r: return -1\n            mid = (l + r) // 2\n            if nums[mid] == target: return mid\n            if nums[mid] < target: return helper(mid + 1, r)\n            return helper(l, mid - 1)\n        return helper(0, len(nums) - 1)"
    },
    {
        "doc_id": 30,
        "chunk_id": 2,
        "chunk_type": "function",
        "file_name": "704.BinarySearch.py",
        "text": "def helper(l, r):\n            if l > r: return -1\n            mid = (l + r) // 2\n            if nums[mid] == target: return mid\n            if nums[mid] < target: return helper(mid + 1, r)\n            return helper(l, mid - 1)"
    },
    {
        "doc_id": 31,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "20.ValidParentheses.py",
        "text": "def isValid(self, s: str) -> bool:\n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n                if mapping[char] != top_element:\n                    return False\n            else:\n                stack.append(char)\n        return not stack"
    },
    {
        "doc_id": 31,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "20.ValidParentheses.py",
        "text": "def checkBrackets(self, s: str) -> bool:\n        # Simplified check for just parentheses\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0"
    },
    {
        "doc_id": 32,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "1283.FindtheSmallestDivisorGivenaThreshold.py",
        "text": "def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        l = 1\n        r = max(nums)\n        while l < r:\n            m = (l+r) // 2\n            result = sum([1 + n//m if n%m else n//m for n in nums])\n            if result > threshold:\n                l = m + 1\n            else:\n                r = m\n        return l"
    },
    {
        "doc_id": 33,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "125.ValidPalindrome.py",
        "text": "def isPalindrome(self, s: str) -> bool:\n        filtered_chars = [char.lower() for char in s if char.isalnum()]\n        return filtered_chars == filtered_chars[::-1]"
    },
    {
        "doc_id": 33,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "125.ValidPalindrome.py",
        "text": "def isPalindromeTwoPointers(self, s: str) -> bool:\n        l, r = 0, len(s) - 1\n        while l < r:\n            while l < r and not self.alphaNum(s[l]):\n                l += 1\n            while r > l and not self.alphaNum(s[r]):\n                r -= 1\n            if s[l].lower() != s[r].lower():\n                return False\n            l, r = l + 1, r - 1\n        return True"
    },
    {
        "doc_id": 33,
        "chunk_id": 2,
        "chunk_type": "function",
        "file_name": "125.ValidPalindrome.py",
        "text": "def alphaNum(self, c):\n        return (ord('A') <= ord(c) <= ord('Z') or \n                ord('a') <= ord(c) <= ord('z') or \n                ord('0') <= ord(c) <= ord('9'))"
    },
    {
        "doc_id": 34,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "53.MaximumSubarray.py",
        "text": "def maxSubArray(self, nums: List[int]) -> int:\n        max_so_far = nums[0]\n        current_max = nums[0]\n        for i in range(1, len(nums)):\n            current_max = max(nums[i], current_max + nums[i])\n            max_so_far = max(max_so_far, current_max)\n        return max_so_far"
    },
    {
        "doc_id": 34,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "53.MaximumSubarray.py",
        "text": "def maxSubArrayDnC(self, nums: List[int]) -> int:\n        # Placeholder for Divide and Conquer approach\n        return self.maxSubArray(nums)"
    },
    {
        "doc_id": 35,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "1329.SorttheMatrixDiagonally.py",
        "text": "def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\n        self.rows = len(mat)\n        self.cols = len(mat[0])\n        self.diagonalRowsCrawler(mat)\n        return mat"
    },
    {
        "doc_id": 35,
        "chunk_id": 1,
        "chunk_type": "function",
        "file_name": "1329.SorttheMatrixDiagonally.py",
        "text": "def diagonalRowsCrawler(self, mat: List[List[int]]) -> None:\n        col = self.cols\n        for row in range(self.rows):\n            # iterate through diagonals on first row\n            while col:\n                col -= 1\n                self.diagonalValueSort(mat, row, col)\n            # iterate through diagonals on other rows\n            self.diagonalValueSort(mat, row, col)"
    },
    {
        "doc_id": 35,
        "chunk_id": 2,
        "chunk_type": "function",
        "file_name": "1329.SorttheMatrixDiagonally.py",
        "text": "def diagonalValueSort(self, mat: List[List[int]], row: int, col: int) -> None:\n        diagonal_values = []\n        # gather values\n        while row < self.rows and col < self.cols:\n            diagonal_values.append(mat[row][col])\n            row += 1\n            col += 1\n        # sort values\n        diagonal_values.sort()\n        # replace current values with sorted\n        while row > 0 and col > 0:\n            row -= 1\n            col -= 1\n            mat[row][col] = diagonal_values.pop()"
    },
    {
        "doc_id": 36,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "3.LongestSubstringWithoutRepeatingCharacters.py",
        "text": "def lengthOfLongestSubstring(self, s: str) -> int:\n        i = 0\n        j = 1\n        lss = 0\n        length = len(s)\n        if length < 2:\n            return length\n        s += s[-1]\n        while j <= length:\n            if len(set(s[i:j])) < len(s[i:j]):\n                i += 1\n            lss = max(lss, len(s[i:j]))\n            j += 1\n        return lss"
    },
    {
        "doc_id": 37,
        "chunk_id": 0,
        "chunk_type": "function",
        "file_name": "containsDuplicate.py",
        "text": "def containsNearbyDuplicate(self, nums, k):\n    if len(nums) <= k + 1: return len(nums) != len(set(nums))\n    if k == 0: return False\n    s = set(nums[:k])\n    for i in range(k, len(nums)):\n        if nums[i] in s: return True\n        else:\n            s.remove(nums[i - k])\n            s.add(nums[i])\n    return False"
    }
]